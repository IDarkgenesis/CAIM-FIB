plot(er_graph, vertex.label=NA, vertex.size=3)
# GENERAR GRAFS
er_graph <- erdos.renyi.game(100, 2/100)
library(igraph)
# GENERAR GRAFS
er_graph <- erdos.renyi.game(100, 2/100)
plot(er_graph, vertex.label=NA, vertex.size=3)
ws_graph <- watts.strogatz.game(1, 100, 4, 0.05)
ba_graph <- barabasi.game(100)
plot(er_graph, vertex.label=NA, vertex.size=3)
plot(ws_graph, layout=layout.circle, vertex.label=NA, vertex.size=3)
plot(ba_graph, vertex.label=NA, vertex.size=3)
g <- graph.lattice( c(10,10) )
E(g)$weight <- runif(ecount(g))
E(g)$color <- "grey"
E(g)[ weight > 0.9 ]$color <- "red"
plot(g, vertex.size=2, vertex.label=NA, layout=layout.kamada.kawai,
edge.width=2+3*E(g)$weight)
v <- vector(1,20)
vec.vector <- (1,20)
vec <- seq(1,3, by=0.2)
vec
vec <- seq(0,1, by=0.005)
vec
vec <- seq(0,1, by=0.0005)
vec
for(i in 1:2:10)
length(vec)
length(vec)
vec[0]
vec[0]
vec[1]
vec[1001]
vec[2001]
nSamples = 15
step <- N/nSamples
N <- length(vec)
nSamples = 15
step <- N/nSamples
step
nSamples = 20
step <- N/nSamples
step
N <- length(vec)
nSamples = 20
step <- as.integer(N/nSamples)
step
prob <- seq(20)
prob
while(i < N && auxIndex <= nSamples) {
prob[auxIndex] <- vec[i]
i <- i + step
auxIndex <- auxIndex + 1
}
vec <- seq(0,1, by=0.0005)
N <- length(vec)
nSamples = 20
prob <- seq(20)
step <- as.integer(N/nSamples)
auxIndex <- 1
while(i < N && auxIndex <= nSamples) {
prob[auxIndex] <- vec[i]
i <- i + step
auxIndex <- auxIndex + 1
}
prob
N <- length(vec)
nSamples = 40
prob <- seq(nSamples)
step <- as.integer(N/nSamples)
auxIndex <- 1
while(i < N && auxIndex <= nSamples) {
prob[auxIndex] <- vec[i]
i <- i + step
auxIndex <- auxIndex + 1
}
prob
while(i < N && auxIndex <= nSamples) {
prob[auxIndex] <- vec[i]
i <- i + step
auxIndex <- auxIndex + 1
}
prob
# CREAR SAMPLES PER PLOT
vec <- seq(0,1, by=0.0005)
N <- length(vec)
nSamples = 40
prob <- seq(nSamples)
step <- as.integer(N/nSamples)
auxIndex <- 1
while(i < N && auxIndex <= nSamples) {
prob[auxIndex] <- vec[i]
i <- i + step
auxIndex <- auxIndex + 1
}
while(i < N && auxIndex <= nSamples) {
prob[auxIndex] <- 5#vec[i]
i <- i + step
auxIndex <- auxIndex + 1
}
while(auxIndex <= nSamples) {
prob[auxIndex] <- 5
i <- i + step
auxIndex <- auxIndex + 1
}
N <- length(vec)
nSamples = 40
prob <- seq(nSamples)
step <- as.integer(N/nSamples)
auxIndex <- 1
i->1
i<-1
while(auxIndex <= nSamples) {
prob[auxIndex] <- vec[i]
i <- i + step
auxIndex <- auxIndex + 1
}
N <- length(vec)
nSamples = 20
prob <- seq(nSamples)
step <- as.integer(N/nSamples)
auxIndex <- 1
i<-1
while(auxIndex <= nSamples) {
prob[auxIndex] <- vec[i]
i <- i + step
auxIndex <- auxIndex + 1
}
prob
# CREAR SAMPLES PER PLOT
vec <- seq(0,1, by=0.0005)
N <- length(vec)
nSamples = 40
prob <- seq(nSamples)
step <- as.integer(N/nSamples)
auxIndex <- 1
i<-1
while(auxIndex <= nSamples) {
prob[auxIndex] <- vec[i]
i <- i + step
auxIndex <- auxIndex + 1
}
prob
2**2
for(x in range(1,2,10)){
print(x)
}
for(x in range(1,10)){
print(x)
}
for(x in range(1,10)){
print(x)
}
nSamples = 15
prob = seq(nSamples)
for(i in 1:10){
prob[i] = 10 ** i/5
}
PROB
prob
15:-1
View(ws_graph)
15:1
15:0
(nSamples-1):0
nSamples = 15
prob = seq(nSamples)
(nSamples-1):0
for(i in 15:-1){
prob[i] = 10 ** -(i/5)
}
10 ** -0
10 ** -15/5
10 ** -14/5
14/5
10**-1
nSamples = 15
index <- 1
for(i in (nSamples-1):0){
prob[index] = 10 ** -(i/5)
index <- index + 1
}
prob
nSamples = 20
index <- 1
for(i in (nSamples-1):0){
prob[index] = 10 ** -(i/5)
index <- index + 1
}
prob
nSamples = 15
index <- 1
for(i in (nSamples-1):0){
prob[index] = 10 ** -(i/5)
index <- index + 1
}
prob
nSamples = 15
index <- 1
for(i in (nSamples-1):0){
prob[index] = 10 ** -(i/6)
index <- index + 1
}
prob
nSamples = 15
index <- 1
for(i in (nSamples-1):0){
prob[index] = 10 ** -(i/10)
index <- index + 1
}
prob
nSamples = 15
index <- 1
for(i in (nSamples-1):0){
prob[index] = 10 ** -(i/5)
index <- index + 1
}
prob
nSamples = 15
nSamples = 15
index <- 1
for(i in (nSamples-1):0){
prob[index] = 10 ** -(i/3)
index <- index + 1
}
prob
nSamples = 30
index <- 1
for(i in (nSamples-1):0){
prob[index] = 10 ** -(i/5)
index <- index + 1
}
prob
nSamples = 16
nSamples = 16
index <- 1
for(i in (nSamples-1):0){
prob[index] = 10 ** -(i/4)
index <- index + 1
}
prob
# If we want a value that starts with p = 0.000x we need to select two numbers such that nSamples/div == 4
nSamples = 16
div = nSamples/4
index <- 1
for(i in (nSamples-1):0){
prob[index] = 10 ** -(i/4)
index <- index + 1
}
# If we want a value that starts with p = 0.000x we need to select two numbers such that nSamples/div == 4
nSamples = 16
div = nSamples/4
index <- 1
for(i in (nSamples-1):0){
prob[index] = 10 ** -(i/div)
index <- index + 1
}
prob
# If we want a value that starts with p = 0.000x we need to select two numbers such that nSamples/div == 4
nSamples = 20
div = nSamples/4
index <- 1
for(i in (nSamples-1):0){
prob[index] = 10 ** -(i/div)
index <- index + 1
}
prob
index <- 1
for(i in (nSamples-1):0){
prob[index] <- 10 ** -(i/div)
index <- index + 1
}
prob
(nSamples-1):0
prob <- seq(nSamples)
prob
index <- 1
for(i in (nSamples-1):0){
prob[index] <- 10 ** -(i/div)
index <- index + 1
}
prob
# If we want a value that starts with p = 0.000x we need to select two numbers such that nSamples/div == 4
nSamples = 20
div = nSamples/4
prob <- seq(nSamples)
index <- 1
for(i in (nSamples-1):0){
prob[index] <- 10 ** -(i/div)
index <- index + 1
}
prob
# If we want a value that starts with p = 0.000x we need to select two numbers such that nSamples/div == 4
nSamples = 15
div = nSamples/4
prob <- seq(nSamples)
index <- 1
for(i in (nSamples-1):0){
prob[index] <- 10 ** -(i/div)
index <- index + 1
}
prob
avShortPath = seq(nSamples)
avShortPath
clustCoeff <- seq(nSamples)
clustCoeff
firstIt = TRUE
avShortPath
index <- index + 1
# If we want a value that starts with p = 0.000x we need to select two numbers such that nSamples/div == 4
nSamples = 15
div = nSamples/4
prob <- seq(nSamples)
index <- 1
for(i in (nSamples-1):0){
prob[index] <- 10 ** -(i/div)
index <- index + 1
}
prob
avShortPath <- seq(nSamples)
clustCoeff <- seq(nSamples)
index <- 1
for(i in prob) {
ws <- watts.strogatz.game(1, 100, 4, i)
avShortPath[index] <- average.path.length(ws)
avShortPath[index] <- avShortPath[index]/avShortPath[1]
clustCoeff[index] <- transitivity(ws)
clustCoeff[index] <- clustCoeff[index]/clustCoeff[1]
index <- index + 1
}
avShortPath
# If we want a value that starts with p = 0.000x we need to select two numbers such that nSamples/div == 4
nSamples = 15
div = nSamples/4
prob <- seq(nSamples)
index <- 1
for(i in (nSamples-1):0){
prob[index] <- 10 ** -(i/div)
index <- index + 1
}
prob
avShortPath <- seq(nSamples)
clustCoeff <- seq(nSamples)
index <- 1
for(i in prob) {
ws <- watts.strogatz.game(1, 1000, 4, i)
avShortPath[index] <- average.path.length(ws)
avShortPath[index] <- avShortPath[index]/avShortPath[1]
clustCoeff[index] <- transitivity(ws)
clustCoeff[index] <- clustCoeff[index]/clustCoeff[1]
index <- index + 1
}
avShortPath
